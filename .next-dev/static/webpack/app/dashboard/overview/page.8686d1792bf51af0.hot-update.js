"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/overview/page",{

/***/ "(app-pages-browser)/./src/features/dashboard/pages/overview/query.ts":
/*!********************************************************!*\
  !*** ./src/features/dashboard/pages/overview/query.ts ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeOverviewSummary: () => (/* binding */ computeOverviewSummary)\n/* harmony export */ });\nconst STAGE_LABELS = {\n    new: \"New\",\n    contacted: \"Contacted\",\n    qualified: \"Qualified\",\n    disqualified: \"Disqualified\",\n    converted: \"Converted\"\n};\nfunction computeOverviewSummary(input) {\n    const { leads, revenueKpis, customerCounts, recentActivity } = input;\n    const totalLeads = leads.length;\n    const stageCounts = {\n        new: 0,\n        contacted: 0,\n        qualified: 0,\n        disqualified: 0,\n        converted: 0\n    };\n    const sourceCounts = new Map();\n    let convertedCount = 0;\n    for (const raw of leads){\n        const status = raw.status || \"new\";\n        if (status in stageCounts) {\n            stageCounts[status] += 1;\n        }\n        if (status === \"converted\") {\n            convertedCount += 1;\n        }\n        const sourceKey = (raw.source || \"unknown\").toString().trim().toLowerCase() || \"unknown\";\n        sourceCounts.set(sourceKey, (sourceCounts.get(sourceKey) || 0) + 1);\n    }\n    const stages = Object.keys(stageCounts).map((status)=>{\n        const count = stageCounts[status];\n        const percentage = totalLeads > 0 ? count * 100 / totalLeads : 0;\n        return {\n            status,\n            label: STAGE_LABELS[status],\n            count,\n            percentage\n        };\n    });\n    const totalBySource = Array.from(sourceCounts.values()).reduce((sum, v)=>sum + v, 0);\n    const leadSources = Array.from(sourceCounts.entries()).map((param)=>{\n        let [source, count] = param;\n        return {\n            source,\n            count,\n            percentage: totalBySource > 0 ? count * 100 / totalBySource : 0\n        };\n    }).sort((a, b)=>b.count - a.count);\n    const baseCustomerTotal = customerCounts.total > 0 ? customerCounts.total : customerCounts.active + customerCounts.churned;\n    const realizedGross = revenueKpis.realized_total_minor || 0;\n    const realizedTax = revenueKpis.realized_tax_minor || 0;\n    const realizedNet = Math.max(0, realizedGross - realizedTax);\n    const grossProfit = revenueKpis.gross_profit_minor || 0;\n    const cogsMinor = Math.max(0, realizedNet - grossProfit);\n    const safeCustomerTotal = baseCustomerTotal > 0 ? baseCustomerTotal : 1;\n    const customerLifetimeValueMinor = Math.floor(realizedNet / safeCustomerTotal);\n    const customerAcquisitionCostMinor = Math.floor(cogsMinor / safeCustomerTotal);\n    const baseRetentionDenominator = customerCounts.active + customerCounts.churned;\n    const customerRetentionRatePercent = baseRetentionDenominator > 0 ? customerCounts.active * 100 / baseRetentionDenominator : 0;\n    const leadConversionRatePercent = totalLeads > 0 ? convertedCount * 100 / totalLeads : 0;\n    const metrics = {\n        customerAcquisitionCostMinor,\n        customerLifetimeValueMinor,\n        customerRetentionRatePercent,\n        leadConversionRatePercent,\n        totalLeads,\n        totalCustomers: baseCustomerTotal\n    };\n    const recent = recentActivity.slice(0, 4);\n    return {\n        metrics,\n        stages,\n        leadSources,\n        recentActivity: recent\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9mZWF0dXJlcy9kYXNoYm9hcmQvcGFnZXMvb3ZlcnZpZXcvcXVlcnkudHMiLCJtYXBwaW5ncyI6Ijs7OztBQThDQSxNQUFNQSxlQUFpRDtJQUNyREMsS0FBSztJQUNMQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsY0FBYztJQUNkQyxXQUFXO0FBQ2I7QUFFTyxTQUFTQyx1QkFBdUJDLEtBQW9CO0lBQ3pELE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxXQUFXLEVBQUVDLGNBQWMsRUFBRUMsY0FBYyxFQUFFLEdBQUdKO0lBRS9ELE1BQU1LLGFBQWFKLE1BQU1LLE1BQU07SUFFL0IsTUFBTUMsY0FBZ0Q7UUFDcERiLEtBQUs7UUFDTEMsV0FBVztRQUNYQyxXQUFXO1FBQ1hDLGNBQWM7UUFDZEMsV0FBVztJQUNiO0lBRUEsTUFBTVUsZUFBZSxJQUFJQztJQUV6QixJQUFJQyxpQkFBaUI7SUFFckIsS0FBSyxNQUFNQyxPQUFPVixNQUFPO1FBQ3ZCLE1BQU1XLFNBQVVELElBQUlDLE1BQU0sSUFBSTtRQUM5QixJQUFJQSxVQUFVTCxhQUFhO1lBQ3pCQSxXQUFXLENBQUNLLE9BQU8sSUFBSTtRQUN6QjtRQUNBLElBQUlBLFdBQVcsYUFBYTtZQUMxQkYsa0JBQWtCO1FBQ3BCO1FBQ0EsTUFBTUcsWUFDSixDQUFDRixJQUFJRyxNQUFNLElBQUksU0FBUSxFQUFHQyxRQUFRLEdBQUdDLElBQUksR0FBR0MsV0FBVyxNQUFNO1FBQy9EVCxhQUFhVSxHQUFHLENBQUNMLFdBQVcsQ0FBQ0wsYUFBYVcsR0FBRyxDQUFDTixjQUFjLEtBQUs7SUFDbkU7SUFFQSxNQUFNTyxTQUF1QyxPQUFRRSxJQUFJLENBQ3ZEZixhQUN1QmdCLEdBQUcsQ0FBQyxDQUFDWDtRQUM1QixNQUFNWSxRQUFRakIsV0FBVyxDQUFDSyxPQUFPO1FBQ2pDLE1BQU1hLGFBQWFwQixhQUFhLElBQUksUUFBUyxNQUFPQSxhQUFhO1FBQ2pFLE9BQU87WUFDTE87WUFDQWMsT0FBT2pDLFlBQVksQ0FBQ21CLE9BQU87WUFDM0JZO1lBQ0FDO1FBQ0Y7SUFDRjtJQUVBLE1BQU1FLGdCQUFnQkMsTUFBTUMsSUFBSSxDQUFDckIsYUFBYXNCLE1BQU0sSUFBSUMsTUFBTSxDQUM1RCxDQUFDQyxLQUFLQyxJQUFNRCxNQUFNQyxHQUNsQjtJQUVGLE1BQU1DLGNBQXdDTixNQUFNQyxJQUFJLENBQ3REckIsYUFBYTJCLE9BQU8sSUFFbkJaLEdBQUcsQ0FBQztZQUFDLENBQUNULFFBQVFVLE1BQU07ZUFBTTtZQUN6QlY7WUFDQVU7WUFDQUMsWUFBWUUsZ0JBQWdCLElBQUksUUFBUyxNQUFPQSxnQkFBZ0I7UUFDbEU7T0FDQ1MsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVkLEtBQUssR0FBR2EsRUFBRWIsS0FBSztJQUVuQyxNQUFNZSxvQkFDSnBDLGVBQWVxQyxLQUFLLEdBQUcsSUFDbkJyQyxlQUFlcUMsS0FBSyxHQUNwQnJDLGVBQWVzQyxNQUFNLEdBQUd0QyxlQUFldUMsT0FBTztJQUVwRCxNQUFNQyxnQkFBZ0J6QyxZQUFZMEMsb0JBQW9CLElBQUk7SUFDMUQsTUFBTUMsY0FBYzNDLFlBQVk0QyxrQkFBa0IsSUFBSTtJQUN0RCxNQUFNQyxjQUFjQyxLQUFLQyxHQUFHLENBQUMsR0FBR04sZ0JBQWdCRTtJQUNoRCxNQUFNSyxjQUFjaEQsWUFBWWlELGtCQUFrQixJQUFJO0lBQ3RELE1BQU1DLFlBQVlKLEtBQUtDLEdBQUcsQ0FBQyxHQUFHRixjQUFjRztJQUU1QyxNQUFNRyxvQkFBb0JkLG9CQUFvQixJQUFJQSxvQkFBb0I7SUFFdEUsTUFBTWUsNkJBQTZCTixLQUFLTyxLQUFLLENBQzNDUixjQUFjTTtJQUdoQixNQUFNRywrQkFBK0JSLEtBQUtPLEtBQUssQ0FDN0NILFlBQVlDO0lBR2QsTUFBTUksMkJBQ0p0RCxlQUFlc0MsTUFBTSxHQUFHdEMsZUFBZXVDLE9BQU87SUFFaEQsTUFBTWdCLCtCQUNKRCwyQkFBMkIsSUFDdkIsZUFBZ0JoQixNQUFNLEdBQUcsTUFBT2dCLDJCQUNoQztJQUVOLE1BQU1FLDRCQUNKdEQsYUFBYSxJQUFJLGlCQUFrQixNQUFPQSxhQUFhO0lBRXpELE1BQU11RCxVQUEyQjtRQUMvQko7UUFDQUY7UUFDQUk7UUFDQUM7UUFDQXREO1FBQ0F3RCxnQkFBZ0J0QjtJQUNsQjtJQUVBLE1BQU11QixTQUFTMUQsZUFBZTJELEtBQUssQ0FBQyxHQUFHO0lBRXZDLE9BQU87UUFDTEg7UUFDQXhDO1FBQ0FjO1FBQ0E5QixnQkFBZ0IwRDtJQUNsQjtBQUNGIiwic291cmNlcyI6WyJEOlxcRGVsdGEgSVZcXFNvZndhcmVzXFxnbGFzc1xcc2FuZGJveFxcc2hhZGNuLWNybS1kYXNoYm9hcmRcXHNyY1xcZmVhdHVyZXNcXGRhc2hib2FyZFxccGFnZXNcXG92ZXJ2aWV3XFxxdWVyeS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEFjdGl2aXR5TG9nIH0gZnJvbSBcIkAvZmVhdHVyZXMvZGFzaGJvYXJkL3BhZ2VzL2FjdGl2aXR5LWxvZ3MvZGF0YS9hY3Rpdml0eS1sb2dzLWRhdGFcIjtcbmltcG9ydCB0eXBlIHsgUmV2ZW51ZUtwaXMgfSBmcm9tIFwiQC9mZWF0dXJlcy9kYXNoYm9hcmQvcGFnZXMvcmVwb3J0cy9yZXZlbnVlL3F1ZXJ5XCI7XG5pbXBvcnQgdHlwZSB7IExlYWRTdGF0dXMgfSBmcm9tIFwiQC9mZWF0dXJlcy9kYXNoYm9hcmQvcGFnZXMvbGVhZHMvdHlwZXMvbGVhZFwiO1xuXG5leHBvcnQgdHlwZSBPdmVydmlld1N0YWdlS2V5ID0gTGVhZFN0YXR1cztcblxuZXhwb3J0IGludGVyZmFjZSBPdmVydmlld01ldHJpY3Mge1xuICBjdXN0b21lckFjcXVpc2l0aW9uQ29zdE1pbm9yOiBudW1iZXI7XG4gIGN1c3RvbWVyTGlmZXRpbWVWYWx1ZU1pbm9yOiBudW1iZXI7XG4gIGN1c3RvbWVyUmV0ZW50aW9uUmF0ZVBlcmNlbnQ6IG51bWJlcjtcbiAgbGVhZENvbnZlcnNpb25SYXRlUGVyY2VudDogbnVtYmVyO1xuICB0b3RhbExlYWRzOiBudW1iZXI7XG4gIHRvdGFsQ3VzdG9tZXJzOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3ZlcnZpZXdTdGFnZUJyZWFrZG93bkl0ZW0ge1xuICBzdGF0dXM6IE92ZXJ2aWV3U3RhZ2VLZXk7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIGNvdW50OiBudW1iZXI7XG4gIHBlcmNlbnRhZ2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdmVydmlld0xlYWRTb3VyY2VJdGVtIHtcbiAgc291cmNlOiBzdHJpbmc7XG4gIGNvdW50OiBudW1iZXI7XG4gIHBlcmNlbnRhZ2U6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdmVydmlld1N1bW1hcnkge1xuICBtZXRyaWNzOiBPdmVydmlld01ldHJpY3M7XG4gIHN0YWdlczogT3ZlcnZpZXdTdGFnZUJyZWFrZG93bkl0ZW1bXTtcbiAgbGVhZFNvdXJjZXM6IE92ZXJ2aWV3TGVhZFNvdXJjZUl0ZW1bXTtcbiAgcmVjZW50QWN0aXZpdHk6IEFjdGl2aXR5TG9nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3ZlcnZpZXdJbnB1dCB7XG4gIGxlYWRzOiBBcnJheTx7IHN0YXR1cz86IHN0cmluZyB8IG51bGw7IHNvdXJjZT86IHN0cmluZyB8IG51bGwgfT47XG4gIHJldmVudWVLcGlzOiBSZXZlbnVlS3BpcztcbiAgY3VzdG9tZXJDb3VudHM6IHtcbiAgICBhY3RpdmU6IG51bWJlcjtcbiAgICBjaHVybmVkOiBudW1iZXI7XG4gICAgdG90YWw6IG51bWJlcjtcbiAgfTtcbiAgcmVjZW50QWN0aXZpdHk6IEFjdGl2aXR5TG9nW107XG59XG5cbmNvbnN0IFNUQUdFX0xBQkVMUzogUmVjb3JkPE92ZXJ2aWV3U3RhZ2VLZXksIHN0cmluZz4gPSB7XG4gIG5ldzogXCJOZXdcIixcbiAgY29udGFjdGVkOiBcIkNvbnRhY3RlZFwiLFxuICBxdWFsaWZpZWQ6IFwiUXVhbGlmaWVkXCIsXG4gIGRpc3F1YWxpZmllZDogXCJEaXNxdWFsaWZpZWRcIixcbiAgY29udmVydGVkOiBcIkNvbnZlcnRlZFwiLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVPdmVydmlld1N1bW1hcnkoaW5wdXQ6IE92ZXJ2aWV3SW5wdXQpOiBPdmVydmlld1N1bW1hcnkge1xuICBjb25zdCB7IGxlYWRzLCByZXZlbnVlS3BpcywgY3VzdG9tZXJDb3VudHMsIHJlY2VudEFjdGl2aXR5IH0gPSBpbnB1dDtcblxuICBjb25zdCB0b3RhbExlYWRzID0gbGVhZHMubGVuZ3RoO1xuXG4gIGNvbnN0IHN0YWdlQ291bnRzOiBSZWNvcmQ8T3ZlcnZpZXdTdGFnZUtleSwgbnVtYmVyPiA9IHtcbiAgICBuZXc6IDAsXG4gICAgY29udGFjdGVkOiAwLFxuICAgIHF1YWxpZmllZDogMCxcbiAgICBkaXNxdWFsaWZpZWQ6IDAsXG4gICAgY29udmVydGVkOiAwLFxuICB9O1xuXG4gIGNvbnN0IHNvdXJjZUNvdW50cyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbiAgbGV0IGNvbnZlcnRlZENvdW50ID0gMDtcblxuICBmb3IgKGNvbnN0IHJhdyBvZiBsZWFkcykge1xuICAgIGNvbnN0IHN0YXR1cyA9IChyYXcuc3RhdHVzIHx8IFwibmV3XCIpIGFzIE92ZXJ2aWV3U3RhZ2VLZXk7XG4gICAgaWYgKHN0YXR1cyBpbiBzdGFnZUNvdW50cykge1xuICAgICAgc3RhZ2VDb3VudHNbc3RhdHVzXSArPSAxO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBcImNvbnZlcnRlZFwiKSB7XG4gICAgICBjb252ZXJ0ZWRDb3VudCArPSAxO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VLZXkgPVxuICAgICAgKHJhdy5zb3VyY2UgfHwgXCJ1bmtub3duXCIpLnRvU3RyaW5nKCkudHJpbSgpLnRvTG93ZXJDYXNlKCkgfHwgXCJ1bmtub3duXCI7XG4gICAgc291cmNlQ291bnRzLnNldChzb3VyY2VLZXksIChzb3VyY2VDb3VudHMuZ2V0KHNvdXJjZUtleSkgfHwgMCkgKyAxKTtcbiAgfVxuXG4gIGNvbnN0IHN0YWdlczogT3ZlcnZpZXdTdGFnZUJyZWFrZG93bkl0ZW1bXSA9IChPYmplY3Qua2V5cyhcbiAgICBzdGFnZUNvdW50cyxcbiAgKSBhcyBPdmVydmlld1N0YWdlS2V5W10pLm1hcCgoc3RhdHVzKSA9PiB7XG4gICAgY29uc3QgY291bnQgPSBzdGFnZUNvdW50c1tzdGF0dXNdO1xuICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSB0b3RhbExlYWRzID4gMCA/IChjb3VudCAqIDEwMCkgLyB0b3RhbExlYWRzIDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzLFxuICAgICAgbGFiZWw6IFNUQUdFX0xBQkVMU1tzdGF0dXNdLFxuICAgICAgY291bnQsXG4gICAgICBwZXJjZW50YWdlLFxuICAgIH07XG4gIH0pO1xuXG4gIGNvbnN0IHRvdGFsQnlTb3VyY2UgPSBBcnJheS5mcm9tKHNvdXJjZUNvdW50cy52YWx1ZXMoKSkucmVkdWNlKFxuICAgIChzdW0sIHYpID0+IHN1bSArIHYsXG4gICAgMCxcbiAgKTtcbiAgY29uc3QgbGVhZFNvdXJjZXM6IE92ZXJ2aWV3TGVhZFNvdXJjZUl0ZW1bXSA9IEFycmF5LmZyb20oXG4gICAgc291cmNlQ291bnRzLmVudHJpZXMoKSxcbiAgKVxuICAgIC5tYXAoKFtzb3VyY2UsIGNvdW50XSkgPT4gKHtcbiAgICAgIHNvdXJjZSxcbiAgICAgIGNvdW50LFxuICAgICAgcGVyY2VudGFnZTogdG90YWxCeVNvdXJjZSA+IDAgPyAoY291bnQgKiAxMDApIC8gdG90YWxCeVNvdXJjZSA6IDAsXG4gICAgfSkpXG4gICAgLnNvcnQoKGEsIGIpID0+IGIuY291bnQgLSBhLmNvdW50KTtcblxuICBjb25zdCBiYXNlQ3VzdG9tZXJUb3RhbCA9XG4gICAgY3VzdG9tZXJDb3VudHMudG90YWwgPiAwXG4gICAgICA/IGN1c3RvbWVyQ291bnRzLnRvdGFsXG4gICAgICA6IGN1c3RvbWVyQ291bnRzLmFjdGl2ZSArIGN1c3RvbWVyQ291bnRzLmNodXJuZWQ7XG5cbiAgY29uc3QgcmVhbGl6ZWRHcm9zcyA9IHJldmVudWVLcGlzLnJlYWxpemVkX3RvdGFsX21pbm9yIHx8IDA7XG4gIGNvbnN0IHJlYWxpemVkVGF4ID0gcmV2ZW51ZUtwaXMucmVhbGl6ZWRfdGF4X21pbm9yIHx8IDA7XG4gIGNvbnN0IHJlYWxpemVkTmV0ID0gTWF0aC5tYXgoMCwgcmVhbGl6ZWRHcm9zcyAtIHJlYWxpemVkVGF4KTtcbiAgY29uc3QgZ3Jvc3NQcm9maXQgPSByZXZlbnVlS3Bpcy5ncm9zc19wcm9maXRfbWlub3IgfHwgMDtcbiAgY29uc3QgY29nc01pbm9yID0gTWF0aC5tYXgoMCwgcmVhbGl6ZWROZXQgLSBncm9zc1Byb2ZpdCk7XG5cbiAgY29uc3Qgc2FmZUN1c3RvbWVyVG90YWwgPSBiYXNlQ3VzdG9tZXJUb3RhbCA+IDAgPyBiYXNlQ3VzdG9tZXJUb3RhbCA6IDE7XG5cbiAgY29uc3QgY3VzdG9tZXJMaWZldGltZVZhbHVlTWlub3IgPSBNYXRoLmZsb29yKFxuICAgIHJlYWxpemVkTmV0IC8gc2FmZUN1c3RvbWVyVG90YWwsXG4gICk7XG5cbiAgY29uc3QgY3VzdG9tZXJBY3F1aXNpdGlvbkNvc3RNaW5vciA9IE1hdGguZmxvb3IoXG4gICAgY29nc01pbm9yIC8gc2FmZUN1c3RvbWVyVG90YWwsXG4gICk7XG5cbiAgY29uc3QgYmFzZVJldGVudGlvbkRlbm9taW5hdG9yID1cbiAgICBjdXN0b21lckNvdW50cy5hY3RpdmUgKyBjdXN0b21lckNvdW50cy5jaHVybmVkO1xuXG4gIGNvbnN0IGN1c3RvbWVyUmV0ZW50aW9uUmF0ZVBlcmNlbnQgPVxuICAgIGJhc2VSZXRlbnRpb25EZW5vbWluYXRvciA+IDBcbiAgICAgID8gKGN1c3RvbWVyQ291bnRzLmFjdGl2ZSAqIDEwMCkgLyBiYXNlUmV0ZW50aW9uRGVub21pbmF0b3JcbiAgICAgIDogMDtcblxuICBjb25zdCBsZWFkQ29udmVyc2lvblJhdGVQZXJjZW50ID1cbiAgICB0b3RhbExlYWRzID4gMCA/IChjb252ZXJ0ZWRDb3VudCAqIDEwMCkgLyB0b3RhbExlYWRzIDogMDtcblxuICBjb25zdCBtZXRyaWNzOiBPdmVydmlld01ldHJpY3MgPSB7XG4gICAgY3VzdG9tZXJBY3F1aXNpdGlvbkNvc3RNaW5vcixcbiAgICBjdXN0b21lckxpZmV0aW1lVmFsdWVNaW5vcixcbiAgICBjdXN0b21lclJldGVudGlvblJhdGVQZXJjZW50LFxuICAgIGxlYWRDb252ZXJzaW9uUmF0ZVBlcmNlbnQsXG4gICAgdG90YWxMZWFkcyxcbiAgICB0b3RhbEN1c3RvbWVyczogYmFzZUN1c3RvbWVyVG90YWwsXG4gIH07XG5cbiAgY29uc3QgcmVjZW50ID0gcmVjZW50QWN0aXZpdHkuc2xpY2UoMCwgNCk7XG5cbiAgcmV0dXJuIHtcbiAgICBtZXRyaWNzLFxuICAgIHN0YWdlcyxcbiAgICBsZWFkU291cmNlcyxcbiAgICByZWNlbnRBY3Rpdml0eTogcmVjZW50LFxuICB9O1xufVxuIl0sIm5hbWVzIjpbIlNUQUdFX0xBQkVMUyIsIm5ldyIsImNvbnRhY3RlZCIsInF1YWxpZmllZCIsImRpc3F1YWxpZmllZCIsImNvbnZlcnRlZCIsImNvbXB1dGVPdmVydmlld1N1bW1hcnkiLCJpbnB1dCIsImxlYWRzIiwicmV2ZW51ZUtwaXMiLCJjdXN0b21lckNvdW50cyIsInJlY2VudEFjdGl2aXR5IiwidG90YWxMZWFkcyIsImxlbmd0aCIsInN0YWdlQ291bnRzIiwic291cmNlQ291bnRzIiwiTWFwIiwiY29udmVydGVkQ291bnQiLCJyYXciLCJzdGF0dXMiLCJzb3VyY2VLZXkiLCJzb3VyY2UiLCJ0b1N0cmluZyIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsInNldCIsImdldCIsInN0YWdlcyIsIk9iamVjdCIsImtleXMiLCJtYXAiLCJjb3VudCIsInBlcmNlbnRhZ2UiLCJsYWJlbCIsInRvdGFsQnlTb3VyY2UiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJzdW0iLCJ2IiwibGVhZFNvdXJjZXMiLCJlbnRyaWVzIiwic29ydCIsImEiLCJiIiwiYmFzZUN1c3RvbWVyVG90YWwiLCJ0b3RhbCIsImFjdGl2ZSIsImNodXJuZWQiLCJyZWFsaXplZEdyb3NzIiwicmVhbGl6ZWRfdG90YWxfbWlub3IiLCJyZWFsaXplZFRheCIsInJlYWxpemVkX3RheF9taW5vciIsInJlYWxpemVkTmV0IiwiTWF0aCIsIm1heCIsImdyb3NzUHJvZml0IiwiZ3Jvc3NfcHJvZml0X21pbm9yIiwiY29nc01pbm9yIiwic2FmZUN1c3RvbWVyVG90YWwiLCJjdXN0b21lckxpZmV0aW1lVmFsdWVNaW5vciIsImZsb29yIiwiY3VzdG9tZXJBY3F1aXNpdGlvbkNvc3RNaW5vciIsImJhc2VSZXRlbnRpb25EZW5vbWluYXRvciIsImN1c3RvbWVyUmV0ZW50aW9uUmF0ZVBlcmNlbnQiLCJsZWFkQ29udmVyc2lvblJhdGVQZXJjZW50IiwibWV0cmljcyIsInRvdGFsQ3VzdG9tZXJzIiwicmVjZW50Iiwic2xpY2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/features/dashboard/pages/overview/query.ts\n"));

/***/ })

});